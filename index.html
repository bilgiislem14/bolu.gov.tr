<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Bolu.gov.tr by bilgiislem14</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Bolu.gov.tr</h1>
      <h2 class="project-tagline">Bolu Valiliği Web Sitesi İçin CSS ve JS dosyaları</h2>
      <a href="https://github.com/bilgiislem14/bolu.gov.tr" class="btn">View on GitHub</a>
      <a href="https://github.com/bilgiislem14/bolu.gov.tr/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/bilgiislem14/bolu.gov.tr/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>//&gt;&gt;excludeStart("jqmBuildExclude", pragmas.jqmBuildExclude);
//&gt;&gt;description: Touch events including: touchstart, touchmove, touchend, tap, taphold, swipe, swipeleft, swiperight
//&gt;&gt;label: Touch
//&gt;&gt;group: Events</p>

<p>define( [ "jquery", "../vmouse", "../support/touch" ], function( jQuery ) {
//&gt;&gt;excludeEnd("jqmBuildExclude");</p>

<p>(function( $, window, undefined ) {
    var $document = $( document ),
        supportTouch = $.mobile.support.touch,
        touchStartEvent = supportTouch ? "touchstart" : "mousedown",
        touchStopEvent = supportTouch ? "touchend" : "mouseup",
        touchMoveEvent = supportTouch ? "touchmove" : "mousemove";</p>

<pre><code>// setup new event shortcuts
$.each( ( "touchstart touchmove touchend " +
    "tap taphold " +
    "swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

    $.fn[ name ] = function( fn ) {
        return fn ? this.bind( name, fn ) : this.trigger( name );
    };

    // jQuery &lt; 1.8
    if ( $.attrFn ) {
        $.attrFn[ name ] = true;
    }
});

function triggerCustomEvent( obj, eventType, event, bubble ) {
    var originalType = event.type;
    event.type = eventType;
    if ( bubble ) {
        $.event.trigger( event, undefined, obj );
    } else {
        $.event.dispatch.call( obj, event );
    }
    event.type = originalType;
}

// also handles taphold
$.event.special.tap = {
    tapholdThreshold: 750,
    emitTapOnTaphold: true,
    setup: function() {
        var thisObject = this,
            $this = $( thisObject ),
            isTaphold = false;

        $this.bind( "vmousedown", function( event ) {
            isTaphold = false;
            if ( event.which &amp;&amp; event.which !== 1 ) {
                return false;
            }

            var origTarget = event.target,
                timer;

            function clearTapTimer() {
                clearTimeout( timer );
            }

            function clearTapHandlers() {
                clearTapTimer();

                $this.unbind( "vclick", clickHandler )
                    .unbind( "vmouseup", clearTapTimer );
                $document.unbind( "vmousecancel", clearTapHandlers );
            }

            function clickHandler( event ) {
                clearTapHandlers();

                // ONLY trigger a 'tap' event if the start target is
                // the same as the stop target.
                if ( !isTaphold &amp;&amp; origTarget === event.target ) {
                    triggerCustomEvent( thisObject, "tap", event );
                } else if ( isTaphold ) {
                    event.preventDefault();
                }
            }

            $this.bind( "vmouseup", clearTapTimer )
                .bind( "vclick", clickHandler );
            $document.bind( "vmousecancel", clearTapHandlers );

            timer = setTimeout( function() {
                if ( !$.event.special.tap.emitTapOnTaphold ) {
                    isTaphold = true;
                }
                triggerCustomEvent( thisObject, "taphold", $.Event( "taphold", { target: origTarget } ) );
            }, $.event.special.tap.tapholdThreshold );
        });
    },
    teardown: function() {
        $( this ).unbind( "vmousedown" ).unbind( "vclick" ).unbind( "vmouseup" );
        $document.unbind( "vmousecancel" );
    }
};

// Also handles swipeleft, swiperight
$.event.special.swipe = {

    // More than this horizontal displacement, and we will suppress scrolling.
    scrollSupressionThreshold: 30,

    // More time than this, and it isn't a swipe.
    durationThreshold: 1000,

    // Swipe horizontal displacement must be more than this.
    horizontalDistanceThreshold: window.devicePixelRatio &gt;= 2 ? 15 : 30,

    // Swipe vertical displacement must be less than this.
    verticalDistanceThreshold: window.devicePixelRatio &gt;= 2 ? 15 : 30,

    getLocation: function ( event ) {
        var winPageX = window.pageXOffset,
            winPageY = window.pageYOffset,
            x = event.clientX,
            y = event.clientY;

        if ( event.pageY === 0 &amp;&amp; Math.floor( y ) &gt; Math.floor( event.pageY ) ||
            event.pageX === 0 &amp;&amp; Math.floor( x ) &gt; Math.floor( event.pageX ) ) {

            // iOS4 clientX/clientY have the value that should have been
            // in pageX/pageY. While pageX/page/ have the value 0
            x = x - winPageX;
            y = y - winPageY;
        } else if ( y &lt; ( event.pageY - winPageY) || x &lt; ( event.pageX - winPageX ) ) {

            // Some Android browsers have totally bogus values for clientX/Y
            // when scrolling/zooming a page. Detectable since clientX/clientY
            // should never be smaller than pageX/pageY minus page scroll
            x = event.pageX - winPageX;
            y = event.pageY - winPageY;
        }

        return {
            x: x,
            y: y
        };
    },

    start: function( event ) {
        var data = event.originalEvent.touches ?
                event.originalEvent.touches[ 0 ] : event,
            location = $.event.special.swipe.getLocation( data );
        return {
                    time: ( new Date() ).getTime(),
                    coords: [ location.x, location.y ],
                    origin: $( event.target )
                };
    },

    stop: function( event ) {
        var data = event.originalEvent.touches ?
                event.originalEvent.touches[ 0 ] : event,
            location = $.event.special.swipe.getLocation( data );
        return {
                    time: ( new Date() ).getTime(),
                    coords: [ location.x, location.y ]
                };
    },

    handleSwipe: function( start, stop, thisObject, origTarget ) {
        if ( stop.time - start.time &lt; $.event.special.swipe.durationThreshold &amp;&amp;
            Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) &gt; $.event.special.swipe.horizontalDistanceThreshold &amp;&amp;
            Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) &lt; $.event.special.swipe.verticalDistanceThreshold ) {
            var direction = start.coords[0] &gt; stop.coords[ 0 ] ? "swipeleft" : "swiperight";

            triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
            triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
            return true;
        }
        return false;

    },

    // This serves as a flag to ensure that at most one swipe event event is
    // in work at any given time
    eventInProgress: false,

    setup: function() {
        var events,
            thisObject = this,
            $this = $( thisObject ),
            context = {};

        // Retrieve the events data for this element and add the swipe context
        events = $.data( this, "mobile-events" );
        if ( !events ) {
            events = { length: 0 };
            $.data( this, "mobile-events", events );
        }
        events.length++;
        events.swipe = context;

        context.start = function( event ) {

            // Bail if we're already working on a swipe event
            if ( $.event.special.swipe.eventInProgress ) {
                return;
            }
            $.event.special.swipe.eventInProgress = true;

            var stop,
                start = $.event.special.swipe.start( event ),
                origTarget = event.target,
                emitted = false;

            context.move = function( event ) {
                if ( !start || event.isDefaultPrevented() ) {
                    return;
                }

                stop = $.event.special.swipe.stop( event );
                if ( !emitted ) {
                    emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
                    if ( emitted ) {

                        // Reset the context to make way for the next swipe event
                        $.event.special.swipe.eventInProgress = false;
                    }
                }
                // prevent scrolling
                if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) &gt; $.event.special.swipe.scrollSupressionThreshold ) {
                    event.preventDefault();
                }
            };

            context.stop = function() {
                    emitted = true;

                    // Reset the context to make way for the next swipe event
                    $.event.special.swipe.eventInProgress = false;
                    $document.off( touchMoveEvent, context.move );
                    context.move = null;
            };

            $document.on( touchMoveEvent, context.move )
                .one( touchStopEvent, context.stop );
        };
        $this.on( touchStartEvent, context.start );
    },

    teardown: function() {
        var events, context;

        events = $.data( this, "mobile-events" );
        if ( events ) {
            context = events.swipe;
            delete events.swipe;
            events.length--;
            if ( events.length === 0 ) {
                $.removeData( this, "mobile-events" );
            }
        }

        if ( context ) {
            if ( context.start ) {
                $( this ).off( touchStartEvent, context.start );
            }
            if ( context.move ) {
                $document.off( touchMoveEvent, context.move );
            }
            if ( context.stop ) {
                $document.off( touchStopEvent, context.stop );
            }
        }
    }
};
$.each({
    taphold: "tap",
    swipeleft: "swipe.left",
    swiperight: "swipe.right"
}, function( event, sourceEvent ) {

    $.event.special[ event ] = {
        setup: function() {
            $( this ).bind( sourceEvent, $.noop );
        },
        teardown: function() {
            $( this ).unbind( sourceEvent );
        }
    };
});
</code></pre>

<p>})( jQuery, this );
//&gt;&gt;excludeStart("jqmBuildExclude", pragmas.jqmBuildExclude);
});
//&gt;&gt;excludeEnd("jqmBuildExclude");</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/bilgiislem14/bolu.gov.tr">Bolu.gov.tr</a> is maintained by <a href="https://github.com/bilgiislem14">bilgiislem14</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
